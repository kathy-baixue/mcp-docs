---
title: 服务器开发者
description: 快速开始 - 面向服务器开发人员
---

import { Accordion, Accordions } from 'fumadocs-ui/components/accordion';

import { Tab, Tabs } from 'fumadocs-ui/components/tabs';

面向服务器开发人员

> 开始构建自己的服务器，以便在Claude Desktop和其他客户端中使用

在本教程中，我们将构建一个简单的MCP天气服务器，并将其连接到主机Claude for Desktop。我们将从基本设置开始，然后进行更复杂的用例。

## 我们将构建什么

许多 LLM 目前不具备获取天气预报和恶劣天气警报的能力。让我们使用 MCP 来解决这个问题。

我们将构建一个服务器，它向客户端暴露两个工具： `get-alerts` and `get-forecast`。然后，我们将服务器连接到MCP主机（在本例中使用Claude for Desktop）：


![ImaImageZoomge](/server-developers-01.png)

![ImaImageZoomge](/server-developers-02.png)


<Callout type="info">
    服务可以连接任何客户端。为了简单起见，我们在这里选择了Claude桌面应用（Claude for DeskTop） ，但我们也有关于[建立自己的client](https://mcp.thinkinai.xyz/docs/quick-start/client-developers) 以及 [这里的其他客户列表](https://modelcontextprotocol.io/clients).
</Callout>


<Accordions type="single">
  <Accordion title="为什么选择Claude for DeskTop而不是Claude.ai？">由于服务器是本地运行的，MCP目前只支持Claude桌面应用做主机。远程主机正在积极开发中。</Accordion>
</Accordions>

## MCP核心概念

MCP服务器可以提供三种主要功能：

1. **Resources**: 客户端可以读取的类文件数据（如API响应或文件内容）
2. **Tools**: LLM可以调用的函数（需要用户批准）
3. **Prompts**: 预先编写的模板，帮助用户完成特定任务

本教程将主要关注工具。


<Tabs items={['Python', 'Node', 'Java','Kotlin','C#']}> 
<Tab title="Python">
        让我们开始构建我们的天气服务器吧！[你可以在这里找到我们将要构建的完整代码。](https://github.com/modelcontextprotocol/quickstart-resources/tree/main/weather-server-python)

        ### 预备知识 [!toc]

        本快速入门假定您熟悉：

        * Python
        * LLM，如Claude

        ### 系统要求 [!toc]

        * 已安装 Python 3.10 或更高版本。
        * 你必须使用 Python MCP SDK 1.2.0 或更高版本。

        ### 设置你的环境 [!toc]

        首先，让我们安装uv并设置我们的Python项目和环境：
        ```ts tab="MacOS/Linux"
        curl -LsSf https://astral.sh/uv/install.sh | sh
        ```
 
        ```ts tab="Windows"
        powershell -ExecutionPolicy ByPass -c "irm https://astral.sh/uv/install.ps1 | iex"
        ```
        之后请务必重启你的终端，以确保 uv 命令被识别。

        现在，让我们创建并设置我们的项目：

        <Tabs items={['MacOS/Linux', 'Windows']}> 
            <Tab title="MacOS/Linux">
            ```bash MacOS/Linux
            # Create a new directory for our project
            uv init weather
            cd weather

            # Create virtual environment and activate it
            uv venv
            source .venv/bin/activate

            # Install dependencies
            uv add "mcp[cli]" httpx

            # Create our server file
            touch weather.py
            ```
            </Tab>
            <Tab title="Windows">
            ```powershell Windows
            # Create a new directory for our project
            uv init weather
            cd weather

            # Create virtual environment and activate it
            uv venv
            .venv\Scripts\activate

            # Install dependencies
            uv add mcp[cli] httpx

            # Create our server file
            new-item weather.py
            ```
            </Tab>
        </Tabs>

        现在让我们深入构建你的服务器。

        ## 构建您的服务 [!toc]

        ### 导入包并设置实例 [!toc]

        将这些添加到你的 `weather.py`文件的顶部：

        ```python
        from typing import Any
        import httpx
        from mcp.server.fastmcp import FastMCP

        # Initialize FastMCP server
        mcp = FastMCP("weather")

        # Constants
        NWS_API_BASE = "https://api.weather.gov"
        USER_AGENT = "weather-app/1.0"
        ```

        FastMCP类使用Python类型提示和文档字符串自动生成工具定义，从而轻松创建和维护 MCP工具。
        ### 帮助函数 [!toc]

        接下来，让我们添加我们的助手函数，用于查询和格式化来自美国国家气象局API的数据：

        ```python
async def make_nws_request(url: str) -> dict[str, Any] | None:
    """Make a request to the NWS API with proper error handling."""
    headers = {
        "User-Agent": USER_AGENT,
        "Accept": "application/geo+json"
    }
    async with httpx.AsyncClient() as client:
        try:
            response = await client.get(url, headers=headers, timeout=30.0)
            response.raise_for_status()
            return response.json()
        except Exception:
            return None

def format_alert(feature: dict) -> str:
    """Format an alert feature into a readable string."""
    props = feature["properties"]
    return f"""
Event: {props.get('event', 'Unknown')}
Area: {props.get('areaDesc', 'Unknown')}
Severity: {props.get('severity', 'Unknown')}
Description: {props.get('description', 'No description available')}
Instructions: {props.get('instruction', 'No specific instructions provided')}
"""
        ```

        ### 实现工具的执行 [!toc]

        工具执行处理程序（execution handler）负责实际执行每个工具的逻辑。让我们添加它：

        ```python
        @mcp.tool()
            async def get_alerts(state: str) -> str:
            """Get weather alerts for a US state.

            Args:
                state: Two-letter US state code (e.g. CA, NY)
            """
            url = f"{NWS_API_BASE}/alerts/active/area/{state}"
            data = await make_nws_request(url)

            if not data or "features" not in data:
                return "Unable to fetch alerts or no alerts found."

            if not data["features"]:
                return "No active alerts for this state."

            alerts = [format_alert(feature) for feature in data["features"]]
            return "\n---\n".join(alerts)

        @mcp.tool()
        async def get_forecast(latitude: float, longitude: float) -> str:
            """Get weather forecast for a location.

            Args:
                latitude: Latitude of the location
                longitude: Longitude of the location
            """
            # First get the forecast grid endpoint
            points_url = f"{NWS_API_BASE}/points/{latitude},{longitude}"
            points_data = await make_nws_request(points_url)

            if not points_data:
                return "Unable to fetch forecast data for this location."

            # Get the forecast URL from the points response
            forecast_url = points_data["properties"]["forecast"]
            forecast_data = await make_nws_request(forecast_url)

            if not forecast_data:
                return "Unable to fetch detailed forecast."

            # Format the periods into a readable forecast
            periods = forecast_data["properties"]["periods"]
            forecasts = []
            for period in periods[:5]:  # Only show next 5 periods
                forecast = f"""
        {period['name']}:
        Temperature: {period['temperature']}°{period['temperatureUnit']}
        Wind: {period['windSpeed']} {period['windDirection']}
        Forecast: {period['detailedForecast']}
        """
            forecasts.append(forecast)

        return "\n---\n".join(forecasts)
        ```

        ### 运行服务器 [!toc]

        最后，让我们初始化并运行服务器：

        ```python
        if __name__ == "__main__":
            # Initialize and run the server
            mcp.run(transport='stdio')
        ```

        您的服务器已完成！运行`uv Run weather.py `以确认一切正常。

        现在让我们从现有的MCP主机Claude for Desktop测试您的服务器。

        ## 使用Claude for Desktop测试您的服务器 [!toc]

        <Callout type="info">
            Claude for Desktop尚不适用于Linux。Linux用户可以继续阅读 [构建客户端](https://mcp.thinkinai.xyz/docs/quick-start/client-developers) 教程，以构建一个 MCP client，连接到我们刚刚构建的 server 。
        </Callout>

        首先，确保您安装了Claude for Desktop。[您可以安装最新版本](https://claude.ai/download) 如果你已经有了Claude for Desktop， **确保它已更新到最新版本。**

        我们需要为您想要使用的任何MCP服务器配置Claude for Desktop。为此，请在文本编辑器中打开Claude for Desktop App配置，该文件在如下位置`~/Library/Application Support/Claude/claude_desktop_config.json` 。如果文件不存在，请确保创建该文件。

        例如，如果你安装了[VS Code](https://code.visualstudio.com/) :

        <Tabs items={['MacOS/Linux', 'Windows']}>
            <Tab title="MacOS/Linux">
                ```bash
                code ~/Library/Application\ Support/Claude/claude_desktop_config.json
                ```
            </Tab>

            <Tab title="Windows">
                ```powershell
                code $env:AppData\Claude\claude_desktop_config.json
                ```
            </Tab>
        </Tabs>

        然后，您将在“mcpServers”键中添加服务器。只有正确配置了至少一个 server，MCP UI 元素才会显示在 Claude for Desktop 中。
        在本例中，我们将添加我们的单个天气服务器，如下所示：

        <Tabs items={['MacOS/Linux', 'Windows']}>
            <Tab title="MacOS/Linux">
                ```json Python
                {
                    "mcpServers": {
                        "weather": {
                            "command": "uv",
                            "args": [
                                "--directory",
                                "/ABSOLUTE/PATH/TO/PARENT/FOLDER/weather",
                                "run",
                                "weather.py"
                            ]
                        }
                    }
                }
                ```
            </Tab>

            <Tab title="Windows">
                ```json Python
                {
                    "mcpServers": {
                        "weather": {
                            "command": "uv",
                            "args": [
                                "--directory",
                                "C:\\ABSOLUTE\\PATH\\TO\\PARENT\\FOLDER\\weather",
                                "run",
                                "weather.py"
                            ]
                        }
                    }
                }
                ```
            </Tab>
        </Tabs>

        <Callout type="warn">
            您可能需要将可执行的`uv` 完整路径放在 `command` 域. 你可以在 MacOS/Linux 上运行 which uv 或在 Windows 上运行 where uv 来获取它。
        </Callout>

        <Callout type="info">
            确保你传入的是你的服务器的绝对路径。
        </Callout>

        这告诉 Claude for Desktop:

        1. 有一个名为 “weather” 的 MCP 服务器
        2. 通过运行 uv --directory /ABSOLUTE/PATH/TO/PARENT/FOLDER/weather run weather.py 来启动它

        保存文件，然后重新启动 **Claude for Desktop**.
    </Tab>
<Tab title="Node">
        让我们开始构建我们的天气服务器吧！ [你可以在这里找到我们将要构建的完整代码。](https://github.com/modelcontextprotocol/quickstart-resources/tree/main/weather-server-typescript)

        ### 预备知识 [!toc]

        本快速入门假定您熟悉：

        * TypeScript
        * LLM，如Claude

        ### 系统要求 [!toc]

        对于TypeScript，请确保您安装了最新版本的Node。

        ### 设置你的环境 [!toc]

        首先，让我们安装Node.js和npm，如果你还没有的话。您可以从以下网址下载它们 [nodejs.org](https://nodejs.org/).
        验证您的 Node.js 安装:

        ```bash
        node --version
        npm --version
        ```

        对于本教程，您需要Node.js版本16或更高版本。
        
        现在，让我们创建并设置我们的项目：

    <Tabs items={['MacOS/Linux', 'Windows']}>
    <Tab value="MacOS/Linux">
            ```bash MacOS/Linux
            # Create a new directory for our project
            mkdir weather
            cd weather

            # Initialize a new npm project
            npm init -y

            # Install dependencies
            npm install @modelcontextprotocol/sdk zod
            npm install -D @types/node typescript

            # Create our files
            mkdir src
            touch src/index.ts
            ```
  </Tab>
  <Tab value="Windows">
            ```powershell Windows
            # Create a new directory for our project
            md weather
            cd weather

            # Initialize a new npm project
            npm init -y

            # Install dependencies
            npm install @modelcontextprotocol/sdk zod
            npm install -D @types/node typescript

            # Create our files
            md src
            new-item src\index.ts
            ```
  </Tab>
</Tabs>

        更新你的 package.json 以添加 type: “module” 和一个 build script：

        ```json title="package.json"
        {
            "type": "module",
            "bin": {
            "weather": "./build/index.js"
        },
            "scripts": {
            "build": "tsc && chmod 755 build/index.js"
        },
            "files": [
            "build"
            ],
        }
        ```

       在你的项目的根目录下创建一个`tsconfig.json`：

        ```json title="tsconfig.json"
        {
            "compilerOptions": {
            "target": "ES2022",
            "module": "Node16",
            "moduleResolution": "Node16",
            "outDir": "./build",
            "rootDir": "./src",
            "strict": true,
            "esModuleInterop": true,
            "skipLibCheck": true,
            "forceConsistentCasingInFileNames": true
        },
            "include": ["src/**/*"],
            "exclude": ["node_modules"]
        }
        ```

        现在，让我们深入构建您的服务器。

        ## 构建您的服务器 [!toc]

        ### 导入包并设置实例 [!toc]

        将这些添加到你的`src/index.ts`文件的顶部：

        ```typescript
        import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
        import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
        import { z } from "zod";

        const NWS_API_BASE = "https://api.weather.gov";
        const USER_AGENT = "weather-app/1.0";

        // Create server instance
        const server = new McpServer({
            name: "weather",
            version: "1.0.0",
            capabilities: {
                resources: {},
                tools: {},
        },
    });
        ```

        ### 帮助函数 [!toc]

        接下来，让我们添加我们的助手函数，用于查询和格式化来自美国国家气象局API的数据：

        ```typescript
        // Helper function for making NWS API requests
        async function makeNWSRequest<T>(url: string): Promise<T | null> {
            const headers = {
                "User-Agent": USER_AGENT,
                Accept: "application/geo+json",
        };

            try {
                const response = await fetch(url, { headers });
                if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
                return (await response.json()) as T;
        } catch (error) {
                console.error("Error making NWS request:", error);
                return null;
            }
        }

        interface AlertFeature {
            properties: {
                event?: string;
                areaDesc?: string;
                severity?: string;
                status?: string;
                headline?: string;
            };
        }

        // Format alert data
        function formatAlert(feature: AlertFeature): string {
            const props = feature.properties;
            return [
                `Event: ${props.event || "Unknown"}`,
                `Area: ${props.areaDesc || "Unknown"}`,
                `Severity: ${props.severity || "Unknown"}`,
                `Status: ${props.status || "Unknown"}`,
                `Headline: ${props.headline || "No headline"}`,
                "---",
            ].join("\n");
        }

        interface ForecastPeriod {
            name?: string;
            temperature?: number;
            temperatureUnit?: string;
            windSpeed?: string;
            windDirection?: string;
            shortForecast?: string;
        }

        interface AlertsResponse {
            features: AlertFeature[];
        }

        interface PointsResponse {
            properties: {
                forecast?: string;
            };
        }

        interface ForecastResponse {
            properties: {
                periods: ForecastPeriod[];
            };
        }
        ```

        ### 实现工具的执行 [!toc]

        工具执行处理程序负责实际执行每个工具的逻辑。让我们添加它：

        ```typescript
        // Register weather tools
        server.tool(
            "get-alerts",
            "Get weather alerts for a state",
            {
                state: z.string().length(2).describe("Two-letter state code (e.g. CA, NY)"),
            },
            async ({ state }) => {
                const stateCode = state.toUpperCase();
                const alertsUrl = `${NWS_API_BASE}/alerts?area=${stateCode}`;
                const alertsData = await makeNWSRequest<AlertsResponse>(alertsUrl);

                if (!alertsData) {
                    return {
                    content: [
                {
                    type: "text",
                    text: "Failed to retrieve alerts data",
                },
                    ],
                };
            }

                const features = alertsData.features || [];
                if (features.length === 0) {
                    return {
                    content: [
                {
                    type: "text",
                    text: `No active alerts for ${stateCode}`,
                },
                    ],
                };
            }

                const formattedAlerts = features.map(formatAlert);
                const alertsText = `Active alerts for ${stateCode}:\n\n${formattedAlerts.join("\n")}`;

                return {
                    content: [
                        {
                            type: "text",
                            text: alertsText,
                        },
                    ],
                };
            },
        );

        server.tool(
            "get-forecast",
            "Get weather forecast for a location",
            {
                latitude: z.number().min(-90).max(90).describe("Latitude of the location"),
                longitude: z.number().min(-180).max(180).describe("Longitude of the location"),
            },
            async ({ latitude, longitude }) => {
                // Get grid point data
                const pointsUrl = `${NWS_API_BASE}/points/${latitude.toFixed(4)},${longitude.toFixed(4)}`;
                const pointsData = await makeNWSRequest<PointsResponse>(pointsUrl);

                if (!pointsData) {
                    return {
                        content: [
                            {
                                type: "text",
                                text: `Failed to retrieve grid point data for coordinates: ${latitude}, ${longitude}. This location may not be supported by the NWS API (only US locations are supported).`,
                            },
                        ],
                    };
                }

                const forecastUrl = pointsData.properties?.forecast;
                if (!forecastUrl) {
                    return {
                        content: [
                            {
                                type: "text",
                                text: "Failed to get forecast URL from grid point data",
                            },
                        ],
                    };
                }

                // Get forecast data
                const forecastData = await makeNWSRequest<ForecastResponse>(forecastUrl);
                if (!forecastData) {
                    return {
                        content: [
                            {
                                type: "text",
                                text: "Failed to retrieve forecast data",
                            },
                        ],
                    };
                }

                const periods = forecastData.properties?.periods || [];
                if (periods.length === 0) {
                    return {
                        content: [
                            {
                                type: "text",
                                text: "No forecast periods available",
                            },
                        ],
                    };
                }

                // Format forecast periods
                const formattedForecast = periods.map((period: ForecastPeriod) =>
                    [
                        `${period.name || "Unknown"}:`,
                        `Temperature: ${period.temperature || "Unknown"}°${period.temperatureUnit || "F"}`,
                        `Wind: ${period.windSpeed || "Unknown"} ${period.windDirection || ""}`,
                        `${period.shortForecast || "No forecast available"}`,
                        "---",
                    ].join("\n"),
                );

                const forecastText = `Forecast for ${latitude}, ${longitude}:\n\n${formattedForecast.join("\n")}`;

                return {
                    content: [
                        {
                            type: "text",
                            text: forecastText,
                        },
                    ],
                };
            },
        );
        ```

        ### 运行服务器 [!toc]

        最后，实现 main 函数以运行 server：

        ```typescript
        async function main() {
            const transport = new StdioServerTransport();
            await server.connect(transport);
            console.error("Weather MCP Server running on stdio");
        }

        main().catch((error) => {
            console.error("Fatal error in main():", error);
            process.exit(1);
        });
        ```

        确保运行 npm run build 以构建你的服务器！这是让你的服务器连接起来非常重要的一步。

        现在让我们从现有的MCP主机Claude for Desktop测试您的服务器。

        ## 使用Claude for Desktop测试您的服务器 [!toc]

        <Callout type="info">
            Claude for Desktop尚未在Linux上可用。Linux用户可以继续阅读 [构建客户端](https://mcp.thinkinai.xyz/docs/quick-start/client-developers) 教程，以构建一个 MCP client，连接到我们刚刚构建的 server 。
        </Callout>

        首先，确保您安装了Claude for Desktop。 [您可以安装最新版本在这里。](https://claude.ai/download) 如果你已经有了Claude for Desktop， **确保它已更新到最新版本。**

        我们需要为您想要使用的任何MCP服务器配置Claude for Desktop。为此，请在文本编辑器中打开Claude for Desktop App配置，该文件在如下位置`~/Library/Application Support/Claude/claude_desktop_config.json` 。如果文件不存在，请确保创建该文件。

        例如，如果你有安装 [VS Code](https://code.visualstudio.com/) :
<Tabs items={['MacOS/Linux', 'Windows']}>
    <Tab value="MacOS/Linux">
            ```bash MacOS/Linux
code ~/Library/Application\ Support/Claude/claude_desktop_config.json
            ```
  </Tab>
  <Tab value="Windows">
            ```powershell Windows
code $env:AppData\Claude\claude_desktop_config.json
            ```
  </Tab>
</Tabs>

然后，您将在“mcpServers”键中添加服务器。只有正确配置了至少一个 server，MCP UI 元素才会显示在 Claude for Desktop 中。

在本例中，我们将添加我们的单个天气服务器
<Tabs items={['MacOS/Linux', 'Windows']}>
    <Tab value="MacOS/Linux">
            ```node title="Node"
{
    "mcpServers": {
        "weather": {
            "command": "node",
            "args": [
                "/ABSOLUTE/PATH/TO/PARENT/FOLDER/weather/build/index.js"
            ]
        }
    }
}
            ```
  </Tab>
  <Tab value="Windows">
            ```node title="Node"
            {
    "mcpServers": {
        "weather": {
            "command": "node",
            "args": [
                "C:\\PATH\\TO\\PARENT\\FOLDER\\weather\\build\\index.js"
            ]
        }
    }
}
            ```
  </Tab>
</Tabs>

        这告诉 Claude for Desktop:

        1. 有一个名为 “weather” 的 MCP 服务器
        2. 通过运行 `node /ABSOLUTE/PATH/TO/PARENT/FOLDER/weather/build/index.js`来启动它

        保存文件，然后重新启动 **Claude for Desktop**.
    </Tab>  
  <Tab title="Java">
         <Callout type="info">
            这是一个基于Spring AI MCP自动配置和引导启动器的快速入门演示。
            要了解如何手动创建同步和异步MCP服务器，请参阅 [Java SDK Server](https://modelcontextprotocol.io/sdk/java/mcp-server) 说明.
        </Callout>

        让我们开始构建我们的天气服务器吧！
        [你可以在这里找到我们将要构建的完整代码。](https://github.com/spring-projects/spring-ai-examples/tree/main/model-context-protocol/weather/starter-stdio-server)

        有关更多信息，请参阅 [MCP Server Boot Starter](https://docs.spring.io/spring-ai/reference/api/mcp/mcp-server-boot-starter-docs.html) 参考文件。
        有关手动MCP服务器实施，请参阅 [MCP Server Java SDK documentation](https://modelcontextprotocol.io/sdk/java/mcp-server).

        ### 系统要求 [!toc]

        * 安装Java 17 or 更高版本.
        * [Spring Boot 3.3.x](https://docs.spring.io/spring-boot/installing.html) 或更高版本

        ### 设置您的环境 [!toc]

        使用[Spring Initializer](https://start.spring.io/) 启动项目。

        您需要添加以下依赖项：
 <Tabs items={['Maven', 'Gradle']}>
    <Tab value="Maven">
            ```bash Maven
         <dependencies>
      <dependency>
          <groupId>org.springframework.ai</groupId>
          <artifactId>spring-ai-starter-mcp-server</artifactId>
      </dependency>

      <dependency>
          <groupId>org.springframework</groupId>
          <artifactId>spring-web</artifactId>
      </dependency>
</dependencies>
            ```
  </Tab>
  <Tab value="Gradle">
      ```bash Gradle
dependencies {
  implementation platform("org.springframework.ai:spring-ai-starter-mcp-server")
  implementation platform("org.springframework:spring-web")
}
      ```
  </Tab>
</Tabs>
        然后通过设置应用程序属性来配置应用程序：

<Tabs items={['application.properties', 'application.yml']}>
            <Tab title="application.properties">
            ```bash application.properties
            spring.main.bannerMode=off
            logging.pattern.console=
            ```
            </Tab>

            <Tab title="application.yml">
            ```yaml application.yml
            logging:
              pattern:
                console:
            spring:
              main:
                banner-mode: off
            ```
            </Tab>
        </Tabs>

        这个 [服务器配置属性](https://docs.spring.io/spring-ai/reference/api/mcp/mcp-server-boot-starter-docs.html#_configuration_properties) 记录所有可用的属性。

        现在，让我们深入构建您的服务器。

        ## 构建您的服务 [!toc]

        ### 天气服务 [!toc]

        让我们实现一个 [WeatherService.java](https://github.com/spring-projects/spring-ai-examples/blob/main/model-context-protocol/weather/starter-stdio-server/src/main/java/org/springframework/ai/mcp/sample/server/WeatherService.java) ，它使用REST客户端来查询来自美国国家气象局API的数据：

        ```java
        @Service
        public class WeatherService {

        private final RestClient restClient;

        public WeatherService() {
            this.restClient = RestClient.builder()
                .baseUrl("https://api.weather.gov")
                .defaultHeader("Accept", "application/geo+json")
                .defaultHeader("User-Agent", "WeatherApiClient/1.0 (your@email.com)")
                .build();
        }

        @Tool(description = "Get weather forecast for a specific latitude/longitude")
        public String getWeatherForecastByLocation(
                double latitude,   // Latitude coordinate
                double longitude   // Longitude coordinate
            ) {
                // Returns detailed forecast including:
                // - Temperature and unit
                // - Wind speed and direction
                // - Detailed forecast description
        }

        @Tool(description = "Get weather alerts for a US state")
        public String getAlerts(
            @ToolParam(description = "Two-letter US state code (e.g. CA, NY)" String state
        ) {
            // Returns active alerts including:
            // - Event type
            // - Affected area
            // - Severity
            // - Description
            // - Safety instructions
        }

        // ......
    }
        ```

        这个`@Service`注释将在你的应用程序上下文中自动注册该service。

        Spring AI的`@Tool`注释，使其易于创建和维护MCP工具。

        自动配置（auto-configuration）将自动向MCP服务器注册这些工具。

        ### 创建你的Boot应用 [!toc]

        ```java
        @SpringBootApplication
        public class McpServerApplication {

            public static void main(String[] args) {
                SpringApplication.run(McpServerApplication.class, args);
            }

            @Bean
            public ToolCallbackProvider weatherTools(WeatherService weatherService) {
                return  MethodToolCallbackProvider.builder().toolObjects(weatherService).build();
            }
        }
        ```

        使用“MethodToolcallback Provider”实用程序将“@Tools”转换为MCP服务器使用的可操作回调。

        ### 运行服务器 [!toc]

        最后，让我们构建服务器：

        ```bash
        ./mvnw clean install
        ```

        这将在“target”文件夹中生成一个“mcp-weather-stdio-server-0.0.1-SNAPSHOT.jar”文件。

        现在让我们从现有的MCP主机Claude for Desktop测试您的服务器。

        ## 使用Claude for Desktop测试您的服务器 [!toc]

       <Callout type="info">
            Claude for Desktop尚不适用于Linux。
        </Callout>

        首先，确保您安装了Claude for Desktop。
        [您可以在此处安装最新版本。](https://claude.ai/download) 如果您已经拥有Claude for Desktop，**请确保它已更新到最新版本**

        我们需要为您想要使用的任何MCP服务器配置Claude for Desktop。
        为此，请在文本编辑器中打开位于`~/Library/ApplicationSupport/Claude/Claude_Desktop_config.json`的Claude for Desktop App配置。
        如果文件不存在，请确保创建该文件。

        例如，如果你已经安装[VS Code](https://code.visualstudio.com/):

        <Tabs items={['MacOS/Linux', 'Windows']}>
    <Tab value="MacOS/Linux">
            ```bash
          code ~/Library/Application\ Support/Claude/claude_desktop_config.json
            ```
  </Tab>
  <Tab value="Windows">
            ```powershell
        code $env:AppData\Claude\claude_desktop_config.json
            ```
  </Tab>
</Tabs>

        然后，您将在`mcpServers`键中添加服务器。
只有正确配置了至少一个 server，MCP UI 元素才会显示在 Claude for Desktop 中。

在本例中，我们将添加我们的单个天气服务器  
       ```java title="java"
       {
  "mcpServers": {
    "spring-ai-mcp-weather": {
      "command": "java",
      "args": [
        "-Dspring.ai.mcp.server.stdio=true",
        "-jar",
        "/ABSOLUTE/PATH/TO/PARENT/FOLDER/mcp-weather-stdio-server-0.0.1-SNAPSHOT.jar"
      ]
    }
  }
}
       ```

        <Callout type="info">
            确保传入服务器的绝对路径。
        </Callout>

        这告诉Claude for Desktop：

        1.有一个名为“我的天气服务器”的MCP服务器

        2.通过运行`java-jar/AABSOLUTE/PATH/To/PARENT/FOLDER/mcp-weather-stdio-server--0.1-SNAPSHOT.jar`来启动它。

        保存文件，然后重新启动**Claude for Desktop**。

        ## 使用Java客户端测试您的服务器 [!toc]

        ### 手动创建MCP客户端 [!toc]

        使用`McpClient`连接到服务器：


        ```java
        var stdioParams = ServerParameters.builder("java")
            .args("-jar", "/ABSOLUTE/PATH/TO/PARENT/FOLDER/mcp-weather-stdio-server-0.0.1-SNAPSHOT.jar")
            .build();

        var stdioTransport = new StdioClientTransport(stdioParams);

        var mcpClient = McpClient.sync(stdioTransport).build();

        mcpClient.initialize();

        ListToolsResult toolsList = mcpClient.listTools();

        CallToolResult weather = mcpClient.callTool(
            new CallToolRequest("getWeatherForecastByLocation",
            Map.of("latitude", "47.6062", "longitude", "-122.3321")));

        CallToolResult alert = mcpClient.callTool(
            new CallToolRequest("getAlerts", Map.of("state", "NY")));

        mcpClient.closeGracefully();
        ```

        ### 使用MCP客户端引导启动器 [!toc]

        使用`spring-ai-starter-mcp-client`依赖项创建一个新的引导启动器应用程序：

        ```xml
        <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-starter-mcp-client</artifactId>
        </dependency>
        ```

        并将`spring.ai.mcp.client.sdio.servers配置`属性设置为指向您的`claude_desktop_config.json`。
        您可以重新使用现有的Anthropic Desktop配置：

        ```properties
        spring.ai.mcp.client.stdio.servers-configuration=file:PATH/TO/claude_desktop_config.json
        ```

        当您启动客户端应用程序时，自动配置将从claude\_desktop\_config.json自动创建MCP客户端。

        有关更多信息，请参阅[MCP客户端启动程序](https://docs.spring.io/spring-ai/reference/api/mcp/mcp-server-boot-client-docs.html)参考文件。

        ## 更多Java MCP服务器示例 [!toc]

        这个[starter-webflux-server](https://github.com/spring-projects/spring-ai-examples/tree/main/model-context-protocol/weather/starter-webflux-server) 演示如何使用SSE传输创建MCP服务器。
        它展示了如何使用Spring Boot的自动配置功能定义和注册MCP工具、资源和提示。
    </Tab>    
<Tab title="Kotlin">
        让我们开始构建我们的天气服务器吧！[你可以在这里找到我们将要构建的完整代码。](https://github.com/modelcontextprotocol/kotlin-sdk/tree/main/samples/weather-stdio-server)

        ### 必备知识 [!toc]

        本快速入门假定您熟悉：

        * Kotlin
        * LLM，如Claude

        ### 系统要求 [!toc]

        * 已安装 Java 17 或更高版本。

        ### 设置你的环境 [!toc]

        首先，让我们安装`java`和`gradle`（如果还没有的话）。

        您可以从[Oracle JDK官方网站](https://www.oracle.com/java/technologies/downloads/)下载`java`.

        验证您的“java”安装：

        ```bash
        java --version
        ```

        现在，让我们创建并设置您的项目：

        <Tabs items={['MacOS/Linux', 'Windows']}>
            <Tab title="MacOS/Linux">
            ```bash MacOS/Linux
            # Create a new directory for our project
            mkdir weather
            cd weather

            # Initialize a new kotlin project
            gradle init
            ```
            </Tab>

            <Tab title="Windows">
            ```powershell Windows
            # Create a new directory for our project
            md weather
            cd weather

            # Initialize a new kotlin project
            gradle init
            ```
            </Tab>
        </Tabs>

        运行`gradle init`后，您将看到创建项目的选项。

        选择**Application**作为项目类型，**Kotlin**作为编程语言，**Java17**作为Java版本。

        或者，您可以使用[IntelliJ IDEA项目向导](https://kotlinlang.org/docs/jvm-get-started.html)创建Kotlin应用程序.

        <Tabs items={['build.gradle.kts', 'build.gradle']}>
            <Tab title="build.gradle.kts">
            ```kotlin build.gradle.kts
            val mcpVersion = "0.4.0"
            val slf4jVersion = "2.0.9"
            val ktorVersion = "3.1.1"

            dependencies {
            implementation("io.modelcontextprotocol:kotlin-sdk:$mcpVersion")
            implementation("org.slf4j:slf4j-nop:$slf4jVersion")
            implementation("io.ktor:ktor-client-content-negotiation:$ktorVersion")
            implementation("io.ktor:ktor-serialization-kotlinx-json:$ktorVersion")
        }
            ```
            </Tab>

            <Tab title="build.gradle">
            ```groovy build.gradle
            def mcpVersion = '0.3.0'
            def slf4jVersion = '2.0.9'
            def ktorVersion = '3.1.1'

            dependencies {
            implementation "io.modelcontextprotocol:kotlin-sdk:$mcpVersion"
            implementation "org.slf4j:slf4j-nop:$slf4jVersion"
            implementation "io.ktor:ktor-client-content-negotiation:$ktorVersion"
            implementation "io.ktor:ktor-serialization-kotlinx-json:$ktorVersion"
        }
            ```
            </Tab>
        </Tabs>

        此外，将以下插件添加到您的构建脚本中：

        <Tabs items={['build.gradle.kts', 'build.gradle']}>
            <Tab title="build.gradle.kts">
            ```kotlin build.gradle.kts
            plugins {
                kotlin("plugin.serialization") version "your_version_of_kotlin"
                id("com.github.johnrengelman.shadow") version "8.1.1"
            }
            ```
            </Tab>

            <Tab title="build.gradle">
            ```groovy build.gradle
            plugins {
                id 'org.jetbrains.kotlin.plugin.serialization' version 'your_version_of_kotlin'
                id 'com.github.johnrengelman.shadow' version '8.1.1'
            }
            ```
            </Tab>
        </Tabs>

        现在，让我们开始深入构建您的服务器。

        ## 构建您的服务器 [!toc]

        ### 设置实例 [!toc]

        添加服务器初始化函数：

        ```kotlin
        // Main function to run the MCP server
        fun `run mcp server`() {
            // Create the MCP Server instance with a basic implementation
            val server = Server(
                Implementation(
                    name = "weather", // Tool name is "weather"
                    version = "1.0.0" // Version of the implementation
                ),
                ServerOptions(
                    capabilities = ServerCapabilities(tools = ServerCapabilities.Tools(listChanged = true))
                )
            )

            // Create a transport using standard IO for server communication
            val transport = StdioServerTransport(
                System.`in`.asInput(),
                System.out.asSink().buffered()
            )

            runBlocking {
                server.connect(transport)
                val done = Job()
                server.onClose {
                    done.complete()
                }
                done.join()
            }
        }
        ```

        ### 天气API助手函数 [!toc]

        接下来，让我们添加用于查询和转换来自美国国家气象局API的响应的函数和数据类：

        ```kotlin
        // Extension function to fetch forecast information for given latitude and longitude
        suspend fun HttpClient.getForecast(latitude: Double, longitude: Double): List<String> {
            val points = this.get("/points/$latitude,$longitude").body<Points>()
            val forecast = this.get(points.properties.forecast).body<Forecast>()
            return forecast.properties.periods.map { period ->
                """
                ${period.name}:
                Temperature: ${period.temperature} ${period.temperatureUnit}
                Wind: ${period.windSpeed} ${period.windDirection}
                Forecast: ${period.detailedForecast}
                """.trimIndent()
            }
        }

        // Extension function to fetch weather alerts for a given state
        suspend fun HttpClient.getAlerts(state: String): List<String> {
            val alerts = this.get("/alerts/active/area/$state").body<Alert>()
            return alerts.features.map { feature ->
                """
                    Event: ${feature.properties.event}
                    Area: ${feature.properties.areaDesc}
                    Severity: ${feature.properties.severity}
                    Description: ${feature.properties.description}
                    Instruction: ${feature.properties.instruction}
                """.trimIndent()
            }
        }

        @Serializable
        data class Points(
            val properties: Properties
        ) {
            @Serializable
            data class Properties(val forecast: String)
        }

        @Serializable
        data class Forecast(
            val properties: Properties
        ) {
        @Serializable
            data class Properties(val periods: List<Period>)

            @Serializable
            data class Period(
                val number: Int, val name: String, val startTime: String, val endTime: String,
                val isDaytime: Boolean, val temperature: Int, val temperatureUnit: String,
                val temperatureTrend: String, val probabilityOfPrecipitation: JsonObject,
                val windSpeed: String, val windDirection: String,
                val shortForecast: String, val detailedForecast: String,
            )
        }

        @Serializable
        data class Alert(
            val features: List<Feature>
        ) {
            @Serializable
            data class Feature(
                val properties: Properties
            )

            @Serializable
            data class Properties(
                val event: String, val areaDesc: String, val severity: String,
                val description: String, val instruction: String?,
            )
        }
        ```

        ### 实现工具的执行 [!toc]

        工具执行处理程序负责实际执行每个工具的逻辑。让我们添加它：


        ```kotlin
        // Create an HTTP client with a default request configuration and JSON content negotiation
        val httpClient = HttpClient {
            defaultRequest {
            url("https://api.weather.gov")
            headers {
                append("Accept", "application/geo+json")
                append("User-Agent", "WeatherApiClient/1.0")
        }
            contentType(ContentType.Application.Json)
        }
            // Install content negotiation plugin for JSON serialization/deserialization
            install(ContentNegotiation) { json(Json { ignoreUnknownKeys = true }) }
        }

        // Register a tool to fetch weather alerts by state
        server.addTool(
            name = "get_alerts",
            description = """
                Get weather alerts for a US state. Input is Two-letter US state code (e.g. CA, NY)
            """.trimIndent(),
            inputSchema = Tool.Input(
                properties = buildJsonObject {
                    putJsonObject("state") {
                        put("type", "string")
                        put("description", "Two-letter US state code (e.g. CA, NY)")
                    }
                },
                required = listOf("state")
            )
        ) { request ->
            val state = request.arguments["state"]?.jsonPrimitive?.content
            if (state == null) {
                return@addTool CallToolResult(
                    content = listOf(TextContent("The 'state' parameter is required."))
                )
            }

            val alerts = httpClient.getAlerts(state)

            CallToolResult(content = alerts.map { TextContent(it) })
        }

            // Register a tool to fetch weather forecast by latitude and longitude
            server.addTool(
                name = "get_forecast",
                description = """
                    Get weather forecast for a specific latitude/longitude
                """.trimIndent(),
                inputSchema = Tool.Input(
                    properties = buildJsonObject {
                        putJsonObject("latitude") { put("type", "number") }
                        putJsonObject("longitude") { put("type", "number") }
                },
                    required = listOf("latitude", "longitude")
                )
            ) { request ->
            val latitude = request.arguments["latitude"]?.jsonPrimitive?.doubleOrNull
            val longitude = request.arguments["longitude"]?.jsonPrimitive?.doubleOrNull
            if (latitude == null || longitude == null) {
                return@addTool CallToolResult(
                    content = listOf(TextContent("The 'latitude' and 'longitude' parameters are required."))
                )
        }

            val forecast = httpClient.getForecast(latitude, longitude)

            CallToolResult(content = forecast.map { TextContent(it) })
        }
        ```

        ### 运行服务器 [!toc]

        最后，实现运行服务器的主要功能：

        ```kotlin
        fun main() = `run mcp server`()
        ```

        确保运行`/gradlew build`来构建你的服务器。这是让你的服务器连接起来非常重要的一步。

        现在让我们从现有的MCP主机Claude for Desktop测试您的服务器。

        ## 使用Claude for Desktop测试您的服务器 [!toc]

        <Callout type="info">
            Claude for Desktop尚不适用于Linux上。Linux用户可以继续学习[构建客户端](https://mcp.thinkinai.xyz/docs/quick-start/client-developers)教程，以构建一个连接到我们刚刚构建的服务器的MCP客户端。
        </Callout>

        首先，确保您安装了Claude for Desktop。[您可以安装最新版本在这里。](https://claude.ai/download)如果您已经拥有Claude for Desktop，**请确保它已更新到最新版本**

        我们需要为您想要使用的任何MCP服务器配置Claude for Desktop。 为此，请在文本编辑器中打开位于`~/Library/ApplicationSupport/Claude/Claude_Desktop_config.json`的Claude for Desktop App配置。 如果文件不存在，请确保创建该文件。


        例如，如果你有[VS code](https://code.visualstudio.com/)已安装：

        <Tabs items={["MacOS/Linux", "Windows"]}>
            <Tab title="JSON">
            ```bash MacOS/Linux
            code ~/Library/Application\ Support/Claude/claude_desktop_config.json
            ```
            </Tab>

            <Tab title="PowerShell">
            ```powershell Windows
            code $env:AppData\Claude\claude_desktop_config.json
            ```
            </Tab>
        </Tabs>

然后，您将在mcpServers键中添加服务器。 只有正确配置了至少一个 server，MCP UI 元素才会显示在 Claude for Desktop 中。

在本例中，我们将添加我们的单个天气服务器

        <Tabs items={["MacOS/Linux", "Windows"]}>
            <Tab title="JSON">
            ```json MacOS/Linux
            {
                "mcpServers": {
                    "weather": {
                        "command": "java",
                        "args": [
                            "-jar",
                            "/ABSOLUTE/PATH/TO/PARENT/FOLDER/weather/build/libs/weather-0.1.0-all.jar"
                        ]
                    }
                }
            }
            ```
            </Tab>

            <Tab title="JSON">
            ```json Windows
            {
                "mcpServers": {
                    "weather": {
                        "command": "java",
                        "args": [
                            "-jar",
                            "C:\\PATH\\TO\\PARENT\\FOLDER\\weather\\build\\libs\\weather-0.1.0-all.jar"
                        ]
                    }
                }
            }
            ```
            </Tab>
        </Tabs>

        这将告诉Claude for Desktop:

        1.有一个名为“天气”的MCP服务器

        2.通过运行`java-jar/AABSOLUTE/PATH/TO/PARENT/FOLDER/weather/build/libs/weather-0.1.0-all.jar`启动它

        保存文件，然后重新启动**Claude for Desktop**。
    </Tab>
<Tab title="C#">
        让我们开始构建我们的天气服务器吧！[你可以在这里找到我们将要构建的完整代码。](https://github.com/modelcontextprotocol/csharp-sdk/tree/main/samples/QuickstartWeatherServer)

        ### 必备知识 [!toc]

        本快速入门假定您熟悉：

        * C#
        * LLM，如Claude
        * .NET 8 或更高版本

        ### 系统要求 [!toc]

        * 安装[.NET 8 SDK](https://dotnet.microsoft.com/download/dotnet/8.0) 或更高版本。

        ### 配置您的系统环境 [!toc]

        首先，让我们安装`dotnet`，如果你还没有的话。您可以从[微软官方.NET网站](https://dotnet.microsoft.com/download/)下载`dotnet`. 验证您的`dotnet`安装：

        ```bash
        dotnet --version
        ```

        现在，让我们创建并设置您的项目：

        <Tabs items={["MacOS/Linux", "Windows"]}>
            <Tab title="Bash">
            ```bash MacOS/Linux
            # Create a new directory for our project
            mkdir weather
            cd weather
            # Initialize a new C# project
            dotnet new console
            ```
            </Tab>

            <Tab title="PowerShell">
            ```powershell Windows
            # Create a new directory for our project
            mkdir weather
            cd weather
            # Initialize a new C# project
            dotnet new console
            ```
            </Tab>
        </Tabs>

        运行`dotnetnew console `后，您将看到一个新的C#项目。

        您可以在您喜欢的IDE中打开项目，例如[Visual Studio](https://visualstudio.microsoft.com/)或[Rider](https://www.jetbrains.com/rider/).

        或者，您可以使用[Visual Studio项目向导](https://learn.microsoft.com/en-us/visualstudio/get-started/csharp/tutorial-console?view=vs-2022)创建C#应用程序.

        创建项目后，为模型上下文协议SDK添加NuGet包并托管：

        ```bash
        # Add the Model Context Protocol SDK NuGet package
        dotnet add package ModelContextProtocol --prerelease
        # Add the .NET Hosting NuGet package
        dotnet add package Microsoft.Extensions.Hosting
        ```

        现在让我们深入构建你的服务器。

        ## 构建您的服务 [!toc]

        在项目中打开`Program.cs`文件，并将内容替换为以下代码：

        ```csharp
        using Microsoft.Extensions.DependencyInjection;
        using Microsoft.Extensions.Hosting;
        using ModelContextProtocol;
        using System.Net.Http.Headers;

        var builder = Host.CreateEmptyApplicationBuilder(settings: null);

        builder.Services.AddMcpServer()
            .WithStdioServerTransport()
            .WithToolsFromAssembly();

        builder.Services.AddSingleton(_ =>
        {
            var client = new HttpClient() { BaseAddress = new Uri("https://api.weather.gov") };
            client.DefaultRequestHeaders.UserAgent.Add(new ProductInfoHeaderValue("weather-tool", "1.0"));
            return client;
        });

        var app = builder.Build();

        await app.RunAsync();
        ```

        <Callout type="info">
            创建`ApplicationHostBuilder`时，请确保使用`CreateEmptyApplicationBuilder`而不是`CreateDefaultBuilder`。这可确保服务器不会向控制台写入任何其他消息。这仅对使用STDIO传输的服务器是必要的。
        </Callout>

        此代码设置了一个基本的控制台应用程序，该应用程序使用模型上下文协议SDK创建具有标准I/O传输的MCP服务器。

        ### 天气API助手函数 [!toc]

        接下来，使用工具执行处理程序定义一个类，用于查询和转换来自美国国家气象局API的响应：

        ```csharp
        using ModelContextProtocol.Server;
        using System.ComponentModel;
        using System.Net.Http.Json;
        using System.Text.Json;

        namespace QuickstartWeatherServer.Tools;

        [McpServerToolType]
        public static class WeatherTools
        {
            [McpServerTool, Description("Get weather alerts for a US state.")]
            public static async Task<string> GetAlerts(
                HttpClient client,
                [Description("The US state to get alerts for.")] string state)
            {
                var jsonElement = await client.GetFromJsonAsync<JsonElement>($"/alerts/active/area/{state}");
                var alerts = jsonElement.GetProperty("features").EnumerateArray();

                if (!alerts.Any())
            {
                return "No active alerts for this state.";
            }

                return string.Join("\n--\n", alerts.Select(alert =>
            {
                JsonElement properties = alert.GetProperty("properties");
                return $"""
                    Event: {properties.GetProperty("event").GetString()}
                    Area: {properties.GetProperty("areaDesc").GetString()}
                    Severity: {properties.GetProperty("severity").GetString()}
                    Description: {properties.GetProperty("description").GetString()}
                    Instruction: {properties.GetProperty("instruction").GetString()}
                    """;
            }));
            }

                [McpServerTool, Description("Get weather forecast for a location.")]
                public static async Task<string> GetForecast(
                    HttpClient client,
                    [Description("Latitude of the location.")] double latitude,
                    [Description("Longitude of the location.")] double longitude)
            {
                var jsonElement = await client.GetFromJsonAsync<JsonElement>($"/points/{latitude},{longitude}");
                var periods = jsonElement.GetProperty("properties").GetProperty("periods").EnumerateArray();

                return string.Join("\n---\n", periods.Select(period => $"""
                    {period.GetProperty("name").GetString()}
                    Temperature: {period.GetProperty("temperature").GetInt32()}°F
                    Wind: {period.GetProperty("windSpeed").GetString()} {period.GetProperty("windDirection").GetString()}
                    Forecast: {period.GetProperty("detailedForecast").GetString()}
                    """));
            }
        }
        ```

        ### 运行服务器 [!toc]

        最后，使用以下命令运行服务器：

        ```bash
        dotnet run
        ```

        这将启动服务器并监听标准输入/输出上的传入请求。

        ## 使用Claude for Desktop测试您的服务器 [!toc]

        <Callout type="info">
            Claude for Desktop尚不适用于Linux。Linux用户可以继续学习[构建客户端](https://mcp.thinkinai.xyz/docs/quick-start/client-developers)教程，以构建一个连接到我们刚刚构建的服务器的MCP客户端。
        </Callout>

        首先，确保您安装了Claude for Desktop。[您可以安装最新版本 在这里。](https://claude.ai/download)如果您已经拥有Claude for Desktop，**请确保它已更新到最新版本**

        我们需要为您想要使用的任何MCP服务器配置Claude for Desktop。为此，请在文本编辑器中打开位于`~/Library/ApplicationSupport/Claude/Claude_Desktop_config.json`的Claude for Desktop App配置。如果文件不存在，请确保创建该文件。

        例如，如果你有[VSCode](https://code.visualstudio.com/)已安装：
        <Tabs items={["MacOS/Linux", "Windows"]}>
            <Tab title="Bash">
            ```bash MacOS/Linux
            code ~/Library/Application\ Support/Claude/claude_desktop_config.json
            ```
            </Tab>

            <Tab title="PowerShell">
            ```powershell Windows
            code $env:AppData\Claude\claude_desktop_config.json
            ```
            </Tab>
        </Tabs>
 
     
        然后，您将在`mcpServers`键中添加服务器。只有正确配置了至少一个 server，MCP UI 元素才会显示在 Claude for Desktop 中
        在这种情况下，我们将添加单个天气服务器，如下所示：
        <Tabs items={["MacOS/Linux", "Windows"]}>
            <Tab title="Bash">
            ```bash MacOS/Linux
{
    "mcpServers": {
        "weather": {
            "command": "dotnet",
            "args": [
                "run",
                "--project",
                "/ABSOLUTE/PATH/TO/PROJECT",
                "--no-build"
            ]
        }
    }
}
            ```
            </Tab>

            <Tab title="PowerShell">
            ```powershell Windows
            {
    "mcpServers": {
        "weather": {
            "command": "dotnet",
            "args": [
                "run",
                "--project",
                "C:\\ABSOLUTE\\PATH\\TO\\PROJECT",
                "--no-build"
            ]
        }
    }
}
            ```
            </Tab>
        </Tabs>
 
        这将告诉 Claude for Desktop:

        1.有一个名为“天气”的MCP服务器

        2.通过运行`dotnetrun/AABSOLUTE/PATH/TO/PROJECT启动它` ，保存文件，然后重新启动**Claude for Desktop**。
   
   </Tab>    
</Tabs>

## 使用命令进行测试

让我们确保Claude for Desktop正在接收我们在`天气`服务器中暴露的两个工具。你可以通过寻找锤子来做到这一点 <img src="https://mintlify.s3.us-west-1.amazonaws.com/mcp/images/claude-desktop-mcp-hammer-icon.svg" style={{display: 'inline', margin: 0, height: '1.3em'}} /> icon:


![ImaImageZoomge](/server-developers-03.png)

点击锤子图标后，您应该看到列出了两个工具：

![ImaImageZoomge](/available-mcp-tools.png)

如果您的服务器没有被Claude for Desktop接收，请继续进行故障排除部分以获取调试提示。

如果锤子图标已显示，您现在可以在Claude for Desktop中运行以下命令来测试您的服务器：

- 萨克拉门托的天气怎么样？

- 德克萨斯州有哪些活跃天气警报？


![ImaImageZoomge](/server-developers-05.png)


![ImaImageZoomge](/server-developers-06.png)

<Callout type="info">
    由于这是美国国家气象局，因此查询仅适用于美国各地。
</Callout>

## 底层发生了什么

当你问一个问题时：

1.客户端将您的问题发送给Claude

2.Claude分析可用的工具并决定使用哪些

3.客户端通过MCP服务器执行所选工具

4.结果被发送回Claude

5.Claude制定了一个自然语言反应

6.响应显示给您！


## 故障排除

<Accordions  type="multiple">
    <Accordion title="Claude桌面应用集成问题">
        **从Claude桌面应用获取日志**

        与MCP相关的Claude.app日志记录被写入`~/Library/Logs/Claude`的日志文件中：

        - `mcp.log`将包含有关mcp连接和连接失败的一般日志记录。

        - 名为`mcp-server SERVERNAME.log`的文件将包含来自特定服务器的错误（stderr）日志记录。

        您可以运行以下命令列出最近的日志，并跟踪任何新日志：

        ```bash
        # Check Claude's logs for errors
        tail -n 20 -f ~/Library/Logs/Claude/mcp*.log
        ```

        **服务器未在Claude中显示**

        1.检查`claude_desktop_config.json `文件语法

        2.确保项目的路径是绝对的，而不是相对的

        3.完整重启Claude for Desktop

        **无显性原因工具调用失败**

        如果Claude试图使用这些工具，但失败了：

        1.检查Claude的日志是否有错误

        2.验证您的服务器构建和运行是否没有错误

        3.尝试重新启动Claude for Desktop

        **这些都不起作用。我该怎么办**

        请参阅我们的[调试指南](https://mcp.thinkinai.xyz/docs/tutorials/debugging)，了解更好的调试工具和更详细的指导。
    </Accordion>

    <Accordion title="天气API问题">
        **错误：检索网格点数据失败**

        这通常意味着：

        1.坐标在美国境外

        2.NWS API出现问题

        3.你正受到速率限制

        解决方法：

        - 验证您使用的是美国坐标

        - 在请求之间添加少量延迟

        - 查看NWS API状态页面

        **错误：\[STATE]没有活动警报**

        这不是一个错误，只是意味着该州目前没有天气警报。尝试其他州或在恶劣天气期间检查。
    </Accordion>
</Accordions>

<Callout type="info">
    有关更高级的故障排除，请查看我们的[调试MCP](https://mcp.thinkinai.xyz/docs/tutorials/debugging)指南
</Callout>

## 下一步

<Cards cols={2}>
    <Card title="构建一个客户端"  href="https://mcp.thinkinai.xyz/docs/quick-start/client-developers">
        了解如何构建可以连接到服务器的MCP客户端
    </Card>

    <Card title="示例服务器"  href="https://mcp.thinkinai.xyz/docs/example-servers">
        查看我们的官方MCP服务器和实现库
    </Card>

    <Card title="调试指南"  href="https://mcp.thinkinai.xyz/docs/tutorials/debugging">
        了解如何有效地调试MCP服务器和集成
    </Card>

    <Card title="使用LLM构建MCP"  href="https://mcp.thinkinai.xyz/docs/tutorials/building-mcp-with-llms">
        学习如何使用像Claude这样的LLM来加速您的MCP开发
    </Card>
</Cards>
